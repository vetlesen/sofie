{"version":3,"file":"LiveStoreProvider.js","sources":["../../src/LiveStoreProvider/LiveStoreProvider.tsx"],"sourcesContent":["import type {\n  ClientConfig,\n  ContentSourceMap,\n  QueryParams,\n  SanityClient,\n  SanityDocument,\n} from '@sanity/client'\nimport { vercelStegaSplit } from '@vercel/stega'\nimport get from 'lodash.get'\nimport { LRUCache } from 'lru-cache'\nimport { applyPatch } from 'mendoza'\nimport {\n  memo,\n  startTransition,\n  useCallback,\n  useEffect,\n  useMemo,\n  useState,\n  useSyncExternalStore,\n} from 'react'\n\nimport { defineListenerContext as Context, IsEnabledContext } from '../context'\nimport { parseNormalisedJsonPath } from '../csm/jsonpath'\nimport { resolveMapping, walkMap } from '../csm/sourcemap'\nimport type {\n  DefineListenerContext,\n  ListenerGetSnapshot,\n  ListenerSubscribe,\n  Logger,\n} from '../types'\nimport { getQueryCacheKey, type QueryCacheKey } from '../utils'\n\nexport type { Logger }\n\n// Documents share the same cache even if there are nested providers, with a Least Recently Used (LRU) cache\nconst documentsCache = new LRUCache({\n  // Max 500 documents in memory, no big deal if a document is evicted it just means the eventual consistency might take longer\n  max: 500,\n})\n\n/**\n * @internal\n */\nexport interface LiveStoreProviderProps {\n  children: React.ReactNode\n  /**\n   * The Sanity client to use for fetching data and listening to mutations.\n   */\n  client: SanityClient\n  /**\n   * How frequently queries should be refetched in the background to refresh the parts of queries that can't be source mapped.\n   * Setting it to `0` will disable background refresh.\n   * @defaultValue 10000\n   */\n  refreshInterval?: number\n  /**\n   * Listen to mutations on the documents used by your queries, and apply patches directly to the result.\n   * Requires Content Source Maps to work.\n   * @defaultValue true\n   */\n  turboSourceMap?: boolean\n  logger?: Logger\n}\n/**\n * @internal\n */\nconst LiveStoreProvider = memo(function LiveStoreProvider(\n  props: LiveStoreProviderProps,\n) {\n  const {\n    children,\n    client,\n    refreshInterval = 10000,\n    turboSourceMap = true,\n    logger,\n  } = props\n\n  // Check if the client is configured to use Content Source Maps if turbo is enabled\n  // It's wrapped inside `useMemo` so it doesn't call `client.config` more than it needs to, but unlike `useEffect` sooner rather than later\n  useMemo(() => {\n    if (turboSourceMap && !client.config().resultSourceMap) {\n      logger?.error(\n        'The client needs to be configured with `resultSourceMap: true` to enable turbo mode.`',\n      )\n    }\n  }, [client, turboSourceMap, logger])\n\n  const report = useMemo(() => {\n    if (turboSourceMap && client.config().resultSourceMap) {\n      return `Updates that can be traced using Content Source Maps will be applied in real-time. Other updates will be applied every ${refreshInterval}ms.`\n    }\n    return `Updates will be applied every ${refreshInterval}ms.`\n  }, [client, refreshInterval, turboSourceMap])\n  useEffect(() => {\n    if (logger) {\n      logger.log(\n        `[@sanity/preview-kit]: With the current configuration you can expect that: ${report}`,\n      )\n    }\n  }, [logger, report])\n\n  const [subscriptions, setSubscriptions] = useState<QueryCacheKey[]>([])\n  const [snapshots] = useState<QuerySnapshotsCache>(() => new Map())\n  const hooks = useHooks(setSubscriptions)\n  const [context] = useState<DefineListenerContext>(() => {\n    return function defineListener<QueryResult>(\n      initialSnapshot: QueryResult,\n      query: string,\n      params: QueryParams,\n    ) {\n      const key = getQueryCacheKey(query, params)\n\n      // Warm up the cache by setting the initial snapshot, showing stale-while-revalidate\n      if (!snapshots.has(key)) {\n        snapshots.set(key, {\n          result: initialSnapshot,\n          resultSourceMap: {} as ContentSourceMap,\n        })\n      }\n\n      const subscribe: ListenerSubscribe = (onStoreChange) => {\n        const unsubscribe = hooks.subscribe(key, query, params, onStoreChange)\n\n        return () => unsubscribe()\n      }\n      const getSnapshot: ListenerGetSnapshot<QueryResult> = () =>\n        snapshots.get(key)?.result as unknown as QueryResult\n\n      return { subscribe, getSnapshot }\n    } satisfies DefineListenerContext\n  })\n  const [turboIds, setTurboIds] = useState<string[]>([])\n  const turboIdsFromSourceMap = useCallback(\n    (contentSourceMap: ContentSourceMap) => {\n      if (!turboSourceMap) return\n      // This handler only adds ids, on each query fetch. But that's ok since <Turbo /> purges ids that are unused\n      const nextTurboIds = new Set<string>()\n      if (contentSourceMap.documents?.length) {\n        for (const { _id } of contentSourceMap.documents) {\n          nextTurboIds.add(_id)\n        }\n      }\n      startTransition(() =>\n        setTurboIds((prevTurboIds) => {\n          const mergedTurboIds = Array.from(\n            new Set([...prevTurboIds, ...nextTurboIds]),\n          )\n          if (\n            JSON.stringify(mergedTurboIds.sort()) ===\n            JSON.stringify(prevTurboIds.sort())\n          ) {\n            return prevTurboIds\n          }\n          return mergedTurboIds\n        }),\n      )\n    },\n    [turboSourceMap],\n  )\n\n  return (\n    <Context.Provider value={context}>\n      <IsEnabledContext.Provider value>{children}</IsEnabledContext.Provider>\n      {turboSourceMap && (\n        <Turbo\n          cache={hooks.cache}\n          client={client}\n          setTurboIds={setTurboIds}\n          snapshots={snapshots}\n          turboIds={turboIds}\n        />\n      )}\n      {subscriptions.map((key) => {\n        if (!hooks.cache.has(key)) return null\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const { query, params, listeners } = hooks.cache.get(key)!\n        return (\n          <QuerySubscription\n            key={key}\n            client={client}\n            listeners={listeners}\n            params={params}\n            query={query}\n            refreshInterval={refreshInterval}\n            snapshots={snapshots}\n            turboIdsFromSourceMap={turboIdsFromSourceMap}\n          />\n        )\n      })}\n    </Context.Provider>\n  )\n})\nLiveStoreProvider.displayName = 'LiveStoreProvider'\nexport default LiveStoreProvider\n\ninterface QuerySubscriptionProps\n  extends Required<Pick<LiveStoreProviderProps, 'client' | 'refreshInterval'>> {\n  query: string\n  params: QueryParams\n  listeners: Set<() => void>\n  turboIdsFromSourceMap: (contentSourceMap: ContentSourceMap) => void\n  snapshots: QuerySnapshotsCache\n}\nconst QuerySubscription = memo(function QuerySubscription(\n  props: QuerySubscriptionProps,\n) {\n  const {\n    client,\n    refreshInterval,\n    query,\n    params,\n    listeners,\n    snapshots,\n    turboIdsFromSourceMap,\n  } = props\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Make sure any async errors bubble up to the nearest error boundary\n  const [error, setError] = useState<unknown>(null)\n  if (error) throw error\n\n  const [revalidate, startRefresh] = useRevalidate({ refreshInterval })\n  const shouldRefetch = revalidate === 'refresh' || revalidate === 'inflight'\n  useEffect(() => {\n    if (!shouldRefetch) {\n      return\n    }\n\n    let fulfilled = false\n    const controller = new AbortController()\n    // eslint-disable-next-line no-inner-declarations\n    async function effect() {\n      const { signal } = controller\n      const { result, resultSourceMap } = await client.fetch(query, params, {\n        signal,\n        filterResponse: false,\n      })\n\n      if (!signal.aborted) {\n        snapshots.set(getQueryCacheKey(query, params), {\n          result: turboChargeResultIfSourceMap(\n            projectId,\n            dataset,\n            result,\n            resultSourceMap,\n          ),\n          resultSourceMap: resultSourceMap ?? ({} as ContentSourceMap),\n        })\n\n        if (resultSourceMap) {\n          turboIdsFromSourceMap(resultSourceMap)\n        }\n\n        // Notify listeners that snapshots are updated\n        for (const listener of listeners.values()) {\n          listener()\n        }\n        fulfilled = true\n      }\n    }\n    const onFinally = startRefresh()\n    effect()\n      .catch((error) => {\n        if (error.name !== 'AbortError') {\n          setError(error)\n        }\n      })\n      .finally(onFinally)\n    return () => {\n      if (!fulfilled) {\n        controller.abort()\n      }\n    }\n  }, [\n    client,\n    dataset,\n    listeners,\n    params,\n    projectId,\n    query,\n    shouldRefetch,\n    snapshots,\n    startRefresh,\n    turboIdsFromSourceMap,\n  ])\n\n  return null\n})\nQuerySubscription.displayName = 'QuerySubscription'\n\ntype QuerySnapshotsCache = Map<\n  QueryCacheKey,\n  { result: unknown; resultSourceMap: ContentSourceMap }\n>\n\nfunction getTurboCacheKey(\n  projectId: string,\n  dataset: string,\n  _id: string,\n): `${string}-${string}-${string}` {\n  return `${projectId}-${dataset}-${_id}`\n}\n\nfunction onVisibilityChange(onStoreChange: () => void): () => void {\n  document.addEventListener('visibilitychange', onStoreChange)\n  return () => document.removeEventListener('visibilitychange', onStoreChange)\n}\n\n/**\n * Keeps track of when revalidation and activities should be paused\n */\nfunction useShouldPause(): boolean {\n  const [online, setOnline] = useState(false)\n  useEffect(() => {\n    setOnline(navigator.onLine)\n    const online = () => startTransition(() => setOnline(true))\n    const offline = () => startTransition(() => setOnline(false))\n    window.addEventListener('online', online)\n    window.addEventListener('offline', offline)\n    return () => {\n      window.removeEventListener('online', online)\n      window.removeEventListener('offline', offline)\n    }\n  }, [])\n  const visibilityState = useSyncExternalStore(\n    onVisibilityChange,\n    () => document.visibilityState,\n    () => 'hidden' satisfies DocumentVisibilityState,\n  )\n\n  // Should pause activity when offline\n  if (!online) {\n    return true\n  }\n\n  // Should pause when the document isn't visible, as it's likely the user isn't looking at the page\n  if (visibilityState === 'hidden') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * 'hit' - the cache is fresh and valid\n * 'stale' - the cache should revalidate, but can't/shouldn't yet (offline, visibility = hidden)\n * 'refresh' - stale cache, and now is a great time to start refreshing\n * 'inflight' - refreshing cache, revalidate events should be ignored\n */\ntype RevalidateState = 'hit' | 'stale' | 'refresh' | 'inflight'\n/**\n * Keeps track of when queries should revalidate\n */\nfunction useRevalidate(\n  props: Pick<LiveStoreProviderProps, 'refreshInterval'>,\n): [RevalidateState, () => () => void] {\n  const { refreshInterval } = props\n\n  const shouldPause = useShouldPause()\n  const [state, setState] = useState<RevalidateState>('hit')\n\n  // Keep track of indicators for when revalidation should be 'paused'\n  // Like if we're currently offline, or the document isn't visible\n  // Basically if 'stale' and all good we return 'refresh'\n\n  // Next keep track of staleness itself. If we come back online, on a windows focus event\n  // or on a refreshInterval timeout\n  // Basically it controls if cache should be 'hit' or 'stale'\n\n  // How to handle refresh to inflight?\n\n  const startRefresh = useCallback(() => {\n    startTransition(() => setState('inflight'))\n    return () => startTransition(() => setState('hit'))\n  }, [])\n\n  // Revalidate on refreshInterval\n  useEffect(() => {\n    // If refreshInterval is nullish then we don't want to refresh.\n    // Inflight means it's already refreshing and we pause the countdown.\n    // It's only necessary to start the countdown if the cache isn't already stale\n    if (!refreshInterval || state !== 'hit') {\n      return\n    }\n    const timeout = setTimeout(\n      () => startTransition(() => setState('stale')),\n      refreshInterval,\n    )\n    return () => clearTimeout(timeout)\n  }, [refreshInterval, state])\n  // Revalidate on windows focus\n  useEffect(() => {\n    if (state !== 'hit') {\n      return\n    }\n    const onFocus = () => startTransition(() => setState('stale'))\n    window.addEventListener('focus', onFocus)\n    return () => window.removeEventListener('focus', onFocus)\n  }, [refreshInterval, state])\n  // Revalidate on changes to shouldPause\n  useEffect(() => {\n    // Mark as stale pre-emptively if we're offline or the document isn't visible\n    if (shouldPause && state === 'hit') {\n      startTransition(() => setState('stale'))\n    }\n    // If not paused we can mark stale as ready for refresh\n    if (!shouldPause && state === 'stale') {\n      startTransition(() => setState('refresh'))\n    }\n  }, [shouldPause, state])\n\n  return [state, startRefresh]\n}\n\ntype LiveStoreQueryCacheMap = Map<\n  QueryCacheKey,\n  { query: string; params: QueryParams; listeners: Set<() => void> }\n>\n\n/**\n * Keeps track of store subscribers per cache key, in a way that's designed for useSyncExternalStore.\n * The main difference from a typical subscription state with useEffect is that `adding` and `cleanup`\n * is wholly managed by the `subscribe` function in `useSyncExternalStore`, instead of lifecycles in useEffect.\n * And since the `onStoreChange` callback, provided to `subscribe`, notifies React when to re-render,\n * there is no need to use `setState` to trigger a re-render. That's why the Map is persisted in `useState` but the state setter isn't used.\n */\nfunction useHooks(\n  setSubscriptions: React.Dispatch<React.SetStateAction<QueryCacheKey[]>>,\n): {\n  cache: LiveStoreQueryCacheMap\n  subscribe: (\n    key: QueryCacheKey,\n    query: string,\n    params: QueryParams,\n    listener: () => void,\n  ) => () => void\n} {\n  const [cache] = useState<LiveStoreQueryCacheMap>(() => new Map())\n  const subscribe = useCallback(\n    (\n      key: QueryCacheKey,\n      query: string,\n      params: QueryParams,\n      listener: () => void,\n    ) => {\n      if (!cache.has(key)) {\n        cache.set(key, { query, params, listeners: new Set<() => void>() })\n        startTransition(() =>\n          setSubscriptions((prevSubscriptions) => {\n            if (prevSubscriptions.includes(key)) {\n              return prevSubscriptions\n            }\n            return [...prevSubscriptions, key]\n          }),\n        )\n      }\n      const hook = cache.get(key)\n      if (!hook || !hook.listeners) {\n        throw new TypeError('Inconsistent cache for key: ' + key)\n      }\n      const { listeners } = hook\n      listeners.add(listener)\n      return () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          cache.delete(key)\n          startTransition(() =>\n            setSubscriptions((prevSubscriptions) => {\n              if (prevSubscriptions.includes(key)) {\n                return prevSubscriptions.filter((sub) => sub !== key)\n              }\n              return prevSubscriptions\n            }),\n          )\n        }\n      }\n    },\n    [cache, setSubscriptions],\n  )\n  return useMemo(() => ({ cache, subscribe }), [cache, subscribe])\n}\n\ninterface TurboProps extends Pick<LiveStoreProviderProps, 'client'> {\n  turboIds: string[]\n  setTurboIds: React.Dispatch<React.SetStateAction<string[]>>\n  cache: LiveStoreQueryCacheMap\n  snapshots: QuerySnapshotsCache\n}\n/**\n * A turbo-charged mutation observer that uses Content Source Maps to apply mendoza patches on your queries\n */\nconst Turbo = memo(function Turbo(props: TurboProps) {\n  const { client, snapshots, cache, turboIds, setTurboIds } = props\n  const { projectId, dataset } = useMemo(() => {\n    const { projectId, dataset } = client.config()\n    return { projectId, dataset } as Required<\n      Pick<ClientConfig, 'projectId' | 'dataset'>\n    >\n  }, [client])\n\n  // Keep track of document ids that the active `useLiveQuery` hooks care about\n  useEffect(() => {\n    const nextTurboIds = new Set<string>()\n    for (const { query, params } of cache.values()) {\n      const key = getQueryCacheKey(query, params)\n      const snapshot = snapshots.get(key)\n      if (snapshot && snapshot.resultSourceMap?.documents?.length) {\n        for (const { _id } of snapshot.resultSourceMap.documents) {\n          nextTurboIds.add(_id)\n        }\n      }\n    }\n    const nextTurboIdsSnapshot = [...nextTurboIds].sort()\n    if (JSON.stringify(turboIds) !== JSON.stringify(nextTurboIdsSnapshot)) {\n      startTransition(() => setTurboIds(nextTurboIdsSnapshot))\n    }\n  }, [cache, setTurboIds, snapshots, turboIds])\n\n  // Figure out which documents are misssing from the cache\n  const [batch, setBatch] = useState<string[][]>([])\n  useEffect(() => {\n    const batchSet = new Set(batch.flat())\n    const nextBatch = new Set<string>()\n    for (const turboId of turboIds) {\n      if (\n        !batchSet.has(turboId) &&\n        !documentsCache.has(getTurboCacheKey(projectId, dataset, turboId))\n      ) {\n        nextBatch.add(turboId)\n      }\n    }\n    const nextBatchSlice = [...nextBatch].slice(0, 10)\n    if (nextBatchSlice.length === 0) return\n    startTransition(() =>\n      setBatch((prevBatch) => [...prevBatch.slice(-10), nextBatchSlice]),\n    )\n  }, [batch, dataset, projectId, turboIds])\n\n  const [lastMutatedDocumentId, setLastMutatedDocumentId] = useState<string>()\n  // Use the same listen instance and patch documents as they come in\n  useEffect(() => {\n    const subscription = client\n      .listen(\n        `*`,\n        {},\n        {\n          events: ['mutation'],\n          effectFormat: 'mendoza',\n          includePreviousRevision: false,\n          includeResult: false,\n          tag: 'turbo',\n        },\n      )\n      .subscribe((update) => {\n        if (update.type !== 'mutation' || !update.effects?.apply?.length) return\n        // Schedule a reach state update with the ID of the document that were mutated\n        // This react handler will apply the document to related source map snapshots\n        const key = getTurboCacheKey(projectId, dataset, update.documentId)\n        const cachedDocument = documentsCache.peek(key)\n        if (cachedDocument as SanityDocument) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          const patchDoc = { ...cachedDocument } as any\n          delete patchDoc._rev\n          const patchedDocument = applyPatch(patchDoc, update.effects.apply)\n          documentsCache.set(key, patchedDocument)\n        }\n\n        startTransition(() => setLastMutatedDocumentId(update.documentId))\n      })\n    return () => subscription.unsubscribe()\n  }, [client, dataset, projectId])\n\n  // If the last mutated document is in the list over turboIds then lets apply the source map\n  useEffect(() => {\n    if (!lastMutatedDocumentId || !turboIds.includes(lastMutatedDocumentId))\n      return\n\n    const updatedKeys: QueryCacheKey[] = []\n    for (const [key, snapshot] of snapshots.entries()) {\n      if (snapshot.resultSourceMap?.documents?.length) {\n        snapshot.result = turboChargeResultIfSourceMap(\n          projectId,\n          dataset,\n          snapshot.result,\n          snapshot.resultSourceMap,\n        )\n        updatedKeys.push(key)\n      }\n    }\n    for (const updatedKey of updatedKeys) {\n      const listeners = cache.get(updatedKey)?.listeners\n      if (listeners) {\n        for (const listener of listeners) {\n          listener()\n        }\n      }\n    }\n    startTransition(() => setLastMutatedDocumentId(undefined))\n  }, [cache, dataset, lastMutatedDocumentId, projectId, snapshots, turboIds])\n\n  return (\n    <>\n      {batch.map((ids) => (\n        <GetDocuments\n          key={JSON.stringify(ids)}\n          client={client}\n          projectId={projectId}\n          dataset={dataset}\n          ids={ids}\n        />\n      ))}\n    </>\n  )\n})\nTurbo.displayName = 'Turbo'\n\ninterface GetDocumentsProps extends Pick<LiveStoreProviderProps, 'client'> {\n  projectId: string\n  dataset: string\n  ids: string[]\n}\nconst GetDocuments = memo(function GetDocuments(props: GetDocumentsProps) {\n  const { client, projectId, dataset, ids } = props\n\n  useEffect(() => {\n    const missingIds = ids.filter(\n      (id) => !documentsCache.has(getTurboCacheKey(projectId, dataset, id)),\n    )\n    if (missingIds.length === 0) return\n    client.getDocuments(missingIds).then((documents) => {\n      for (const doc of documents) {\n        if (doc && doc?._id) {\n          documentsCache.set(getTurboCacheKey(projectId, dataset, doc._id), doc)\n        }\n      }\n      // eslint-disable-next-line no-console\n    }, console.error)\n  }, [client, dataset, ids, projectId])\n\n  return null\n})\nGetDocuments.displayName = 'GetDocuments'\n\nfunction turboChargeResultIfSourceMap(\n  projectId: string,\n  dataset: string,\n  result: unknown,\n  resultSourceMap?: ContentSourceMap,\n) {\n  if (!resultSourceMap) return result\n\n  return walkMap(result, (value, path) => {\n    const resolveMappingResult = resolveMapping(path, resultSourceMap)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const [mapping, , pathSuffix] = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument = resultSourceMap.documents[mapping.source.document]\n    const sourcePath = resultSourceMap.paths[mapping.source.path]\n    if (sourceDocument && sourceDocument._id) {\n      const cachedDocument = documentsCache.get(\n        getTurboCacheKey(projectId, dataset, sourceDocument._id),\n      )\n\n      const cachedValue = cachedDocument\n        ? get(\n            cachedDocument,\n            parseNormalisedJsonPath(sourcePath + pathSuffix),\n            value,\n          )\n        : value\n      // Preserve stega encoded strings, if they exist\n      if (typeof cachedValue === 'string' && typeof value === 'string') {\n        const { encoded } = vercelStegaSplit(value)\n        const { cleaned } = vercelStegaSplit(cachedValue)\n        return `${encoded}${cleaned}`\n      }\n      return cachedValue\n    }\n\n    return value\n  })\n}\n"],"names":["documentsCache","LRUCache","max","LiveStoreProvider","memo","props","children","client","refreshInterval","turboSourceMap","logger","useMemo","config","resultSourceMap","error","report","concat","useEffect","log","subscriptions","setSubscriptions","useState","snapshots","Map","hooks","useHooks","context","defineListener","initialSnapshot","query","params","key","getQueryCacheKey","has","set","result","subscribe","onStoreChange","unsubscribe","getSnapshot","_a","get","turboIds","setTurboIds","turboIdsFromSourceMap","useCallback","contentSourceMap","nextTurboIds","Set","documents","length","_id","add","startTransition","prevTurboIds","mergedTurboIds","Array","from","JSON","stringify","sort","jsxs","Context","Provider","value","jsx","IsEnabledContext","Turbo","cache","map","listeners","QuerySubscription","displayName","LiveStoreProvider$1","projectId","dataset","setError","revalidate","startRefresh","useRevalidate","shouldRefetch","fulfilled","controller","AbortController","effect","signal","fetch","filterResponse","aborted","turboChargeResultIfSourceMap","listener","values","onFinally","catch","name","finally","abort","getTurboCacheKey","onVisibilityChange","document","addEventListener","removeEventListener","useShouldPause","online","setOnline","navigator","onLine","online2","offline","window","visibilityState","useSyncExternalStore","shouldPause","state","setState","timeout","setTimeout","clearTimeout","onFocus","prevSubscriptions","includes","hook","TypeError","delete","size","filter","sub","_b","snapshot","nextTurboIdsSnapshot","batch","setBatch","batchSet","flat","nextBatch","turboId","nextBatchSlice","slice","prevBatch","lastMutatedDocumentId","setLastMutatedDocumentId","subscription","listen","events","effectFormat","includePreviousRevision","includeResult","tag","update","type","effects","apply","documentId","cachedDocument","peek","patchDoc","_rev","patchedDocument","applyPatch","_c","updatedKeys","entries","push","updatedKey","Fragment","ids","GetDocuments","missingIds","id","getDocuments","then","doc","console","walkMap","path","resolveMappingResult","resolveMapping","mapping","pathSuffix","source","sourceDocument","sourcePath","paths","cachedValue","parseNormalisedJsonPath","encoded","vercelStegaSplit","cleaned"],"mappings":"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"}