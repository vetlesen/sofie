{"version":3,"file":"sourcemap.js","sources":["../../src/csm/sourcemap.ts"],"sourcesContent":["/* eslint-disable no-nested-ternary */\nimport type {\n  ContentSourceMap,\n  ContentSourceMapDocuments,\n  ContentSourceMapMapping,\n} from '@sanity/client'\n\nimport { normalisedJsonPath, parseNormalisedJsonPath } from './jsonpath'\nimport type { Logger, PathSegment } from './types'\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return typeof value === 'object' && value !== null\n}\n\nfunction isArray(value: unknown): value is Array<unknown> {\n  return value !== null && Array.isArray(value)\n}\n\n/** @alpha */\nexport type Encoder<E> = (\n  value: string,\n  sourceDocument: ContentSourceMapDocuments[number],\n  path: PathSegment[],\n) => E\n\n/** @alpha */\nexport function encode<R, E>(\n  result: R,\n  csm: ContentSourceMap,\n  encoder: Encoder<E>,\n): R {\n  return encodeIntoResult(result, csm, encoder) as R\n}\n\n/** @alpha */\nexport function encodeIntoResult<R>(\n  result: R,\n  csm: ContentSourceMap,\n  encoder: Encoder<unknown>,\n): ReturnType<Encoder<unknown>> {\n  return walkMap(result, (value, path) => {\n    // Only map strings, we could extend this in the future to support other types like integers...\n    if (typeof value !== 'string') {\n      return value\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const resolveMappingResult = resolveMapping(path, csm)\n    if (!resolveMappingResult) {\n      return value\n    }\n\n    const [mapping, , pathSuffix] = resolveMappingResult\n    if (mapping.type !== 'value') {\n      return value\n    }\n\n    if (mapping.source.type !== 'documentValue') {\n      return value\n    }\n\n    const sourceDocument =\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      csm.documents[mapping.source.document!]\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const sourcePath = csm.paths[mapping.source.path]\n\n    return encoder(\n      value,\n      sourceDocument,\n      parseNormalisedJsonPath(sourcePath + pathSuffix),\n    )\n  })\n}\n\nexport type WalkMapFn = (value: unknown, path: PathSegment[]) => unknown\n\n// generic way to walk a nested object or array and apply a mapping function to each value\nexport function walkMap(\n  value: unknown,\n  mappingFn: WalkMapFn,\n  path: PathSegment[] = [],\n): unknown {\n  if (isArray(value)) {\n    return value.map((v, idx) => walkMap(v, mappingFn, path.concat(idx)))\n  }\n\n  if (isRecord(value)) {\n    return Object.fromEntries(\n      Object.entries(value).map(([k, v]) => [\n        k,\n        walkMap(v, mappingFn, path.concat(k)),\n      ]),\n    )\n  }\n\n  return mappingFn(value, path)\n}\n\nexport function resolveMapping(\n  resultPath: PathSegment[],\n  csm: ContentSourceMap,\n  logger?: Logger,\n): [ContentSourceMapMapping, string, string] | undefined {\n  const resultJsonPath = normalisedJsonPath(resultPath)\n\n  if (!csm.mappings) {\n    logger?.error?.('Missing mappings', {\n      resultSourceMap: csm,\n    })\n    return undefined\n  }\n\n  if (csm.mappings[resultJsonPath] !== undefined) {\n    return [csm.mappings[resultJsonPath], resultJsonPath, '']\n  }\n\n  const mappings = Object.entries(csm.mappings)\n    .filter(([key]) => resultJsonPath.startsWith(key))\n    .sort(([key1], [key2]) => key2.length - key1.length)\n\n  if (mappings.length == 0) {\n    return undefined\n  }\n\n  const [matchedPath, mapping] = mappings[0]\n  const pathSuffix = resultJsonPath.substring(matchedPath.length)\n  return [mapping, matchedPath, pathSuffix]\n}\n"],"names":["isRecord","value","isArray","Array","encode","result","csm","encoder","encodeIntoResult","walkMap","path","resolveMappingResult","resolveMapping","mapping","pathSuffix","type","source","sourceDocument","documents","document","sourcePath","paths","parseNormalisedJsonPath","mappingFn","arguments","length","undefined","map","v","idx","concat","Object","fromEntries","entries","_ref","k","resultPath","logger","_a","resultJsonPath","normalisedJsonPath","mappings","error","resultSourceMap","filter","_ref2","key","startsWith","sort","_ref3","_ref4","key1","key2","matchedPath","substring"],"mappings":"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"}