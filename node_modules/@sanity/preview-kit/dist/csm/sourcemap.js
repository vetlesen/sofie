import { parseNormalisedJsonPath, normalisedJsonPath } from './jsonpath.js';
function isRecord(value) {
  return typeof value === "object" && value !== null;
}
function isArray(value) {
  return value !== null && Array.isArray(value);
}
function encode(result, csm, encoder) {
  return encodeIntoResult(result, csm, encoder);
}
function encodeIntoResult(result, csm, encoder) {
  return walkMap(result, (value, path) => {
    if (typeof value !== "string") {
      return value;
    }
    const resolveMappingResult = resolveMapping(path, csm);
    if (!resolveMappingResult) {
      return value;
    }
    const [mapping,, pathSuffix] = resolveMappingResult;
    if (mapping.type !== "value") {
      return value;
    }
    if (mapping.source.type !== "documentValue") {
      return value;
    }
    const sourceDocument =
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    csm.documents[mapping.source.document];
    const sourcePath = csm.paths[mapping.source.path];
    return encoder(value, sourceDocument, parseNormalisedJsonPath(sourcePath + pathSuffix));
  });
}
function walkMap(value, mappingFn) {
  let path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  if (isArray(value)) {
    return value.map((v, idx) => walkMap(v, mappingFn, path.concat(idx)));
  }
  if (isRecord(value)) {
    return Object.fromEntries(Object.entries(value).map(_ref => {
      let [k, v] = _ref;
      return [k, walkMap(v, mappingFn, path.concat(k))];
    }));
  }
  return mappingFn(value, path);
}
function resolveMapping(resultPath, csm, logger) {
  var _a;
  const resultJsonPath = normalisedJsonPath(resultPath);
  if (!csm.mappings) {
    (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "Missing mappings", {
      resultSourceMap: csm
    });
    return void 0;
  }
  if (csm.mappings[resultJsonPath] !== void 0) {
    return [csm.mappings[resultJsonPath], resultJsonPath, ""];
  }
  const mappings = Object.entries(csm.mappings).filter(_ref2 => {
    let [key] = _ref2;
    return resultJsonPath.startsWith(key);
  }).sort((_ref3, _ref4) => {
    let [key1] = _ref3;
    let [key2] = _ref4;
    return key2.length - key1.length;
  });
  if (mappings.length == 0) {
    return void 0;
  }
  const [matchedPath, mapping] = mappings[0];
  const pathSuffix = resultJsonPath.substring(matchedPath.length);
  return [mapping, matchedPath, pathSuffix];
}
export { encode, encodeIntoResult, resolveMapping, walkMap };
//# sourceMappingURL=sourcemap.js.map
