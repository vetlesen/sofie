import { vercelStegaCombine } from '@vercel/stega';
import { defineEditLink } from './editIntent.js';
import { encode } from './sourcemap.js';
const filterDefault = _ref => {
  let {
    path
  } = _ref;
  const endPath = path.at(-1);
  if (path.at(-2) === "slug" && endPath === "current") {
    return false;
  }
  if (typeof endPath === "string" && endPath.startsWith("_")) {
    return false;
  }
  if (typeof endPath === "number" && path.at(-2) === "marks" && typeof path.at(-3) === "number" && path.at(-4) === "children" && typeof path.at(-5) === "number") {
    return false;
  }
  if (endPath === "href" && typeof path.at(-2) === "number" && path.at(-3) === "markDefs" && typeof path.at(-4) === "number") {
    return false;
  }
  if (typeof endPath === "string" && typeof path.at(-2) === "number") {
    if (endPath === "style" || endPath === "listItem") {
      return false;
    }
  }
  return true;
};
const TRUNCATE_LENGTH = 20;
function createTranscoder(config) {
  const {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = config;
  const createEditLink = defineEditLink(studioUrl);
  const report = {
    encoded: [],
    skipped: []
  };
  const transcode = (input, sourceDocument, sourcePath) => {
    if ((typeof encodeSourceMapAtPath === "function" ? encodeSourceMapAtPath({
      path: sourcePath,
      filterDefault
    }) : filterDefault({
      path: sourcePath,
      filterDefault
    })) === false) {
      if (logger) {
        report.skipped.push({
          path: prettyPathForLogging(sourcePath),
          value: "".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? "..." : ""),
          length: input.length
        });
      }
      return input;
    }
    if (logger) {
      report.encoded.push({
        path: prettyPathForLogging(sourcePath),
        value: "".concat(input.slice(0, TRUNCATE_LENGTH)).concat(input.length > TRUNCATE_LENGTH ? "..." : ""),
        length: input.length
      });
    }
    return vercelStegaCombine(input, {
      origin: "sanity.io",
      href: createEditLink(sourceDocument, sourcePath)
    }, "auto");
  };
  return (result, csm) => {
    report.encoded.length = 0;
    report.skipped.length = 0;
    return {
      result: encode(result, csm, (value, sourceDocument, path) => transcode(value, sourceDocument, path)),
      report
    };
  };
}
function prettyPathForLogging(path) {
  return path.map((segment, index) => typeof segment === "number" ? "[".concat(segment, "]") : index > 0 ? ".".concat(segment) : segment).join("");
}
export { createTranscoder };
//# sourceMappingURL=transcode.js.map
