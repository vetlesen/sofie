import { requester } from '@sanity/client';
import isPlainObject from 'lodash.isplainobject';
import { createTranscoder } from '../csm/transcode.js';
function transcodeResponse(_ref) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref;
  const transcoder = createTranscoder({
    studioUrl,
    encodeSourceMapAtPath,
    logger
  });
  return {
    onResponse: response => {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!isBodyResponse(response)) {
        return response;
      }
      if (Array.isArray(response.body) || typeof response.body === "string" || isPlainObject(response.body)) {
        if (!isContentSourceMapBody(response.body)) {
          if (logger && isResultBody(response.body)) {
            (_a = logger == null ? void 0 : logger.error) == null ? void 0 : _a.call(logger, "[@sanity/preview-kit]: Missing Content Source Map from response body", response.body);
          }
          return response;
        }
        const transcoderResult = transcoder(response.body.result, response.body.resultSourceMap);
        if (logger) {
          const isSkipping = transcoderResult.report.skipped.length;
          const isEncoding = transcoderResult.report.encoded.length;
          if (isSkipping || isEncoding) {
            (_b = (logger == null ? void 0 : logger.groupCollapsed) || logger.log) == null ? void 0 : _b("[@sanity/preview-kit]: Stega encoding source map into result");
            (_c = logger.log) == null ? void 0 : _c.call(logger, "[@sanity/preview-kit]: Paths encoded: ".concat(transcoderResult.report.encoded.length, ", skipped: ").concat(transcoderResult.report.skipped.length));
          }
          if (transcoderResult.report.encoded.length > 0) {
            (_d = logger == null ? void 0 : logger.log) == null ? void 0 : _d.call(logger, "[@sanity/preview-kit]: Table of encoded paths");
            (_e = (logger == null ? void 0 : logger.table) || logger.log) == null ? void 0 : _e(transcoderResult.report.encoded);
          }
          if (transcoderResult.report.skipped.length > 0) {
            const skipped = /* @__PURE__ */new Set();
            for (const {
              path
            } of transcoderResult.report.skipped) {
              skipped.add(path.replace(/\[\d+\]/g, "[]"));
            }
            (_f = logger == null ? void 0 : logger.log) == null ? void 0 : _f.call(logger, "[@sanity/preview-kit]: List of skipped paths", [...skipped.values()]);
          }
          if (isSkipping || isEncoding) {
            (_g = logger == null ? void 0 : logger.groupEnd) == null ? void 0 : _g.call(logger);
          }
        }
        const body = {
          ...response.body,
          result: transcoderResult.result
        };
        return {
          ...response,
          body
        };
      }
      return response;
    }
  };
}
function createHttpRequest(_ref2) {
  let {
    studioUrl,
    encodeSourceMapAtPath,
    logger
  } = _ref2;
  const superRequester = requester.clone();
  superRequester.use(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- support the improved get-it typings
  transcodeResponse({
    studioUrl,
    encodeSourceMapAtPath,
    logger
  }));
  function httpRequest(options) {
    let requester = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : superRequester;
    return requester({
      maxRedirects: 0,
      ...options
    });
  }
  httpRequest.defaultRequester = superRequester;
  return httpRequest;
}
function isBodyResponse(response) {
  return typeof response === "object" && response !== null;
}
function isResultBody(body) {
  return typeof body === "object" && body !== null && "result" in body;
}
function isContentSourceMapBody(body) {
  return typeof body === "object" && body !== null && "resultSourceMap" in body;
}
export { createHttpRequest, isContentSourceMapBody, isResultBody };
//# sourceMappingURL=request.js.map
