{"version":3,"file":"1.mjs","sources":["../src/values/Path.ts","../src/values/StreamValue.ts","../src/values/dateHelpers.ts","../src/values/utils.ts","../src/evaluator/equality.ts","../src/evaluator/matching.ts","../src/evaluator/ordering.ts","../src/evaluator/operators.ts","../src/evaluator/scope.ts","../src/evaluator/evaluate.ts","../src/evaluator/constantEvaluate.ts","../src/evaluator/pt.ts","../src/evaluator/scoring.ts","../src/evaluator/functions.ts","../src/markProcessor.ts","../src/rawParser.js","../src/traversal.ts","../src/parser.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n","import {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i'),\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n","import {getType, GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {gatherText, matchAnalyzePattern, matchText, matchTokenize, Pattern, Token} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  match: async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import {Value} from '../values'\nimport {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null,\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate,\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor,\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value,\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data._ref\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data._id) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {},\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n    },\n    null,\n  )\n  return evaluate(tree, scope)\n}\n","import {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n      return canConstantEvaluate(node.base)\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null,\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n","import {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj._type !== 'string') return null\n  const children = obj.children\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, Token} from './matching'\nimport {Scope} from './scope'\nimport {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor,\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor,\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport {Executor} from './types'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor,\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n_global.anywhere = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global.anywhere.arity = 1\n\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global.count.arity = 1\n\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global.dateTime.arity = 1\n\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global.defined.arity = 1\n\n// eslint-disable-next-line require-await\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity)\n}\n_global.identity.arity = 0\n\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global.length.arity = 1\n\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global.path.arity = 1\n\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global.string.arity = 1\n\n_global.references = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global.references.arity = (c) => c >= 1\n\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global.round.arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global.now.arity = 0\n\n// eslint-disable-next-line require-await\n_global.boost = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global.boost.arity = 2\n\nconst string: FunctionSet = {}\n\nstring.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring.lower.arity = 1\n\nstring.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring.upper.arity = 1\n\nstring.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring.split.arity = 2\n\n_global.lower = string.lower\n_global.upper = string.upper\n\nstring.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring.startsWith.arity = 2\n\nconst array: FunctionSet = {}\n\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray.join.arity = 2\n\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray.compact.arity = 1\n\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray.unique.arity = 1\n\nconst pt: FunctionSet = {}\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt.text.arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor,\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions.order = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions.order.arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data._score === 'number' ? value.data._score : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions.score.arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta.changedAny = () => {\n  throw new Error('not implemented')\n}\ndelta.changedAny.arity = 1\ndelta.changedAny.mode = 'delta'\n\ndelta.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndelta.changedOnly.arity = 1\ndelta.changedOnly.mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff.changedAny = () => {\n  throw new Error('not implemented')\n}\ndiff.changedAny.arity = 3\n\ndiff.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndiff.changedOnly.arity = 3\n\nconst math: FunctionSet = {}\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.min.arity = 1\n\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.max.arity = 1\n\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath.sum.arity = 1\n\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath.avg.arity = 1\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n}\n","import {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos},\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null,\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {Mark, MarkProcessor, MarkVisitor} from './markProcessor'\nimport {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc(p) {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc(p) {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right,\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs,\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right,\n      )\n  },\n\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param(p) {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`,\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n"],"names":["escapeRegExp","string","replace","pathRegExp","pattern","re","part","split","push","RegExp","concat","join","Path","constructor","__publicField","patternRe","matches","str","test","toJSON","StreamValue","generator","ticker","isDone","data","isArray","get","result","value","Symbol","asyncIterator","i","length","_nextTick","currentResolver","setupTicker","Promise","resolve","tick","fetch","RFC3339_REGEX","parseRFC3339","Date","formatRFC3339","d","year","addLeadingZero","getUTCFullYear","month","getUTCMonth","day","getUTCDate","hour","getUTCHours","minute","getUTCMinutes","second","getUTCSeconds","fractionalSecond","millis","getMilliseconds","num","targetLength","toString","StaticValue","type","Array","element","fromJS","Error","NULL_VALUE","TRUE_VALUE","FALSE_VALUE","DateTime","date","parseToValue","equals","other","getTime","add","secs","copy","setTime","difference","compareTo","fromNumber","Number","isFinite","fromString","fromDateTime","dt","fromPath","path","isIterator","obj","next","val","getType","isEqual","a","b","CHARS","CHARS_WITH_WILDCARD","EDGE_CHARS","MAX_TERM_LENGTH","matchText","tokens","patterns","every","matchTokenize","text","match","matchAnalyzePattern","termsRe","matchPatternRegex","map","some","token","terms","term","slice","gatherText","cb","success","TYPE_ORDER","datetime","number","boolean","partialCompare","aType","bType","totalCompare","aTypeOrder","bTypeOrder","operators","eq","left","right","neq","gt","gte","lt","lte","in","inop","didSucceed","matched","plus","minus","numericOperator","Math","pow","impl","Scope","params","source","context","parent","createNested","isHidden","createHidden","evaluate","node","scope","execute","arguments","undefined","func","EXECUTORS","promiselessApply","then","This","_","Selector","Everything","Parameter","_ref","name","Context","_ref2","key","Parent","_ref3","n","current","OpCall","op","_ref4","leftValue","rightValue","Select","_ref5","alternatives","fallback","alt","altCond","condition","InRange","base","isInclusive","_ref6","leftCmp","rightCmp","Filter","_ref7","expr","baseValue","elem","newScope","exprValue","Projection","_ref8","FuncCall","args","_ref9","PipeFuncCall","_ref10","AccessAttribute","_ref11","hasOwnProperty","AccessElement","_ref12","index","finalIndex","Slice","_ref13","array","leftIdx","rightIdx","Deref","_ref14","id","doc","_id","Value","_ref15","Group","_ref16","Object","_ref17","attributes","attr","attrType","cond","assign","_ref18","elements","isSplat","v","Tuple","Or","_ref19","And","_ref20","Not","_ref21","Neg","_ref22","Pos","_ref23","Asc","Desc","ArrayCoerce","_ref24","Map","_ref25","FlatMap","_ref26","innerValue","inner","evaluateQuery","tree","options","root","dataset","timestamp","identity","sanity","after","before","canConstantEvaluate","DUMMY_SCOPE","tryConstantEvaluate","constantEvaluate","portableTextContent","blockText","texts","arrayText","block","_type","children","child","BM25k","evaluateScore","evaluateMatchScore","innerScore","boost","leftScore","rightScore","res","score","freq","reduce","c","hasReference","pathSet","has","values","countUTF8","count","code","charCodeAt","_global","anywhere","arity","coalesce","arg","dateTime","defined","references","Set","size","scopeValue","round","prec","precValue","isInteger","toFixed","now","toISOString","lower","toLowerCase","upper","toUpperCase","sep","from","startsWith","prefix","arr","buf","needSep","compact","unique","added","iter","pt","projectId","pipeFunctions","order","mappers","directions","mapper","direction","aux","idx","tuple","sort","aTuple","bTuple","unknown","scored","valueScore","_score","newObject","delta","operation","hasBefore","hasAfter","changedAny","mode","changedOnly","diff","math","min","max","sum","avg","namespaces","global","MarkProcessor","marks","parseOptions","hasMark","pos","getMark","shift","process","visitor","mark","call","processString","processStringEnd","prev","curr","position","len","WS","NUM","IDENT","PREC_PAIR","PREC_OR","PREC_AND","PREC_COMP","PREC_ORDER","PREC_ADD","PREC_SUB","PREC_MUL","PREC_DIV","PREC_MOD","PREC_POW","PREC_POS","PREC_NOT","PREC_NEG","parse","skipWS","parseExpr","failPosition","level","startPos","rhs","parseObject","parseString","identLen","parseRegex","numLen","fracLen","expLen","parseFuncCall","lhsLevel","trav","loop","innerPos","parseTraversal","unshift","nextToken","nextPos","identPos","ident","parseRegexStr","isGroup","rangePos","identStart","nameLen","lastPos","pairPos","indexOf","m","exec","flatMap","traverseArray","build","traversePlain","traverseElement","traverseProjection","ESCAPE_SEQUENCE","f","r","t","expandHex","charCode","parseInt","String","fromCharCode","GroqQueryError","EXPR_BUILDER","group","p","everything","this","dblparent","traverse","traversalList","TRAVERSE_BUILDER","traversal","this_attr","neg","sub","mul","div","mod","comp","in_range","char","integer","strValue","float","sci","object","OBJECT_BUILDER","members","func_call","namespace","argumentShouldBeSelector","SELECTOR_BUILDER","allowBoost","funcs","validateArity","pipecall","oldAllowBoost","markName","pair","and","or","not","asc","desc","param","object_expr","extractPropertyKey","object_pair","object_splat","object_splat_this","square_bracket","projection","attr_access","deref","wrap","array_postfix","functionName","argCount","functionsRequiringSelectors","includes","GroqSyntaxError","input","rawParse","processor"],"mappings":"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"}