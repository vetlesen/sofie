{"mappings":"AAAA,mBAAmB,MAAM,GAAG,MAAM,CAAA;AA0HlC;;;;;;GAMG;AACH,QAAA,MAAM,SAAS;WACP,MAAM,UACJ,MAAM,cACF,OAAO,GAClB,MAAM;IAOT;;;;OAIG;iBACuB,MAAM,GAAG,MAAM;IAGzC;;;;OAIG;mBACyB,MAAM,GAAG,MAAM;IAG3C;;;;;OAKG;wBAC8B,IAAI,eAAe,MAAM,GAAG,IAAI;IAIjE;;;;;OAKG;0BACgC,IAAI,eAAe,MAAM,GAAG,IAAI;IAInE;;;;;OAKG;6BACmC,MAAM,UAAU,MAAM,GAAG,IAAI;IAQnE;;;;OAIG;6BACmC,IAAI,GAAG,IAAI;IAWjD;;;;OAIG;mBACyB,MAAM,GAAG,OAAO;IAG5C;;;;OAIG;qBAC2B,MAAM,GAAG,OAAO;CAjF7C,CAAA;AAuVD,eAAe,SAAS,CAAA","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"export type Rule = RegExp | string\ntype CachedRule = [RegExp, string]\ntype IrregularMap = Map<string, string>\n\n// Rule storage - pluralize and singularize need to be run sequentially,\n// while other rules can be optimized using an object for instant lookups.\nconst pluralRules: CachedRule[] = []\nconst singularRules: CachedRule[] = []\nconst uncountables = new Set<string>()\nconst irregularPlurals: IrregularMap = new Map()\nconst irregularSingles: IrregularMap = new Map()\n\n/**\n * Sanitize a pluralization rule to a usable regular expression.\n */\nconst sanitizeRule = (rule: Rule): RegExp =>\n  typeof rule === 'string' ? new RegExp(`^${rule}$`, 'i') : rule\n\n/**\n * Pass in a word token to produce a function that can replicate the case on\n * another word.\n */\nconst restoreCase = (word: string, token: string | undefined): string => {\n  // Edge case\n  if (typeof token !== 'string') return word\n  // Tokens are an exact match.\n  if (word === token) return token\n\n  // Lower cased words. E.g. \"hello\".\n  if (word === word.toLowerCase()) return token.toLowerCase()\n\n  // Upper cased words. E.g. \"WHISKY\".\n  if (word === word.toUpperCase()) return token.toUpperCase()\n\n  // Title cased words. E.g. \"Title\".\n  if (word[0] === word[0].toUpperCase()) {\n    return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase()\n  }\n\n  // Lower cased words. E.g. \"test\".\n  return token.toLowerCase()\n}\n\n/**\n * Sanitize a word by passing in the word and sanitization rules.\n */\nconst sanitizeWord = (\n  token: string,\n  word: string,\n  rules: CachedRule[]\n): string => {\n  // Empty string or doesn't need fixing.\n  if (!token.length || uncountables.has(token)) {\n    return word\n  }\n\n  // Iterate over the sanitization rules and use the first one to match.\n  let { length: len } = rules\n  while (len--) {\n    const rule = rules[len]\n    if (rule[0].test(word)) {\n      // Replace a word using a rule.\n      return word.replace(rule[0], (...args) => {\n        const [match, index] = args\n        // Interpolate a regexp string.\n        const result = rule[1].replace(\n          /\\$(\\d{1,2})/g,\n          (_, index) => args[index] || ''\n        )\n\n        if (match === '') {\n          return restoreCase(word[index - 1], result)\n        }\n\n        return restoreCase(match, result)\n      })\n    }\n  }\n\n  return word\n}\n\nconst compute = (\n  word: string,\n  replaceMap: IrregularMap,\n  keepMap: IrregularMap,\n  rules: CachedRule[]\n): string => {\n  // Get the correct token and case restoration functions.\n  const token = word.toLowerCase()\n\n  // Check against the keep object map.\n  if (keepMap.has(token)) {\n    return restoreCase(word, token)\n  }\n\n  // Check against the replacement map for a direct word replacement.\n  if (replaceMap.has(token)) {\n    return restoreCase(word, replaceMap.get(token))\n  }\n\n  // Run all the rules against the word.\n  return sanitizeWord(token, word, rules)\n}\n\n/**\n * Check if a word is part of the map.\n */\nconst mapHas = (\n  word: string,\n  replaceMap: IrregularMap,\n  keepMap: IrregularMap,\n  rules: CachedRule[]\n): boolean => {\n  const token = word.toLowerCase()\n\n  if (keepMap.has(token)) return true\n  if (replaceMap.has(token)) return false\n\n  return sanitizeWord(token, token, rules) === token\n}\n\n/**\n * Pluralize or singularize a word based on the passed in count.\n *\n * @param word\n * @param count\n * @param inclusive\n */\nconst pluralize = (\n  word: string,\n  count?: number,\n  inclusive?: boolean\n): string => {\n  const pluralized =\n    count === 1 ? pluralize.singular(word) : pluralize.plural(word)\n  if (inclusive) return `${count} ${pluralized}`\n  return pluralized\n}\n\n/**\n * Pluralize a word based.\n *\n * @param word\n */\npluralize.plural = (word: string): string =>\n  compute(word, irregularSingles, irregularPlurals, pluralRules)\n\n/**\n * Singularize a word based.\n *\n * @param word\n */\npluralize.singular = (word: string): string =>\n  compute(word, irregularPlurals, irregularSingles, singularRules)\n\n/**\n * Add a pluralization rule to the collection.\n *\n * @param rule\n * @param replacement\n */\npluralize.addPluralRule = (rule: Rule, replacement: string): void => {\n  pluralRules.push([sanitizeRule(rule), replacement])\n}\n\n/**\n * Add a singularization rule to the collection.\n *\n * @param rule\n * @param replacement\n */\npluralize.addSingularRule = (rule: Rule, replacement: string): void => {\n  singularRules.push([sanitizeRule(rule), replacement])\n}\n\n/**\n * Add an irregular word definition.\n *\n * @param single\n * @param plural\n */\npluralize.addIrregularRule = (single: string, plural: string): void => {\n  const _plural = plural.toLowerCase()\n  const _single = single.toLowerCase()\n\n  irregularSingles.set(_single, _plural)\n  irregularPlurals.set(_plural, _single)\n}\n\n/**\n * Add an uncountable word rule.\n *\n * @param rule\n */\npluralize.addUncountableRule = (rule: Rule): void => {\n  if (typeof rule === 'string') {\n    uncountables.add(rule.toLowerCase())\n    return\n  }\n\n  // Set singular and plural references for the word.\n  pluralize.addPluralRule(rule, '$0')\n  pluralize.addSingularRule(rule, '$0')\n}\n\n/**\n * Test if provided word is plural.\n *\n * @param word\n */\npluralize.isPlural = (word: string): boolean =>\n  mapHas(word, irregularSingles, irregularPlurals, pluralRules)\n\n/**\n * Test if provided word is singular.\n *\n * @param word\n */\npluralize.isSingular = (word: string): boolean =>\n  mapHas(word, irregularPlurals, irregularSingles, singularRules)\n\nconst defaultIrregulars: [string, string][] = [\n  // Pronouns.\n  ['I', 'we'],\n  ['me', 'us'],\n  ['he', 'they'],\n  ['she', 'they'],\n  ['them', 'them'],\n  ['myself', 'ourselves'],\n  ['yourself', 'yourselves'],\n  ['itself', 'themselves'],\n  ['herself', 'themselves'],\n  ['himself', 'themselves'],\n  ['themself', 'themselves'],\n  ['is', 'are'],\n  ['was', 'were'],\n  ['has', 'have'],\n  ['this', 'these'],\n  ['that', 'those'],\n  ['my', 'our'],\n  ['its', 'their'],\n  ['his', 'their'],\n  ['her', 'their'],\n  // Words ending in with a consonant and `o`.\n  ['echo', 'echoes'],\n  ['dingo', 'dingoes'],\n  ['volcano', 'volcanoes'],\n  ['tornado', 'tornadoes'],\n  ['torpedo', 'torpedoes'],\n  // Ends with `us`.\n  ['genus', 'genera'],\n  ['viscus', 'viscera'],\n  // Ends with `ma`.\n  ['stigma', 'stigmata'],\n  ['stoma', 'stomata'],\n  ['dogma', 'dogmata'],\n  ['lemma', 'lemmata'],\n  ['schema', 'schemata'],\n  ['anathema', 'anathemata'],\n  // Other irregular rules.\n  ['ox', 'oxen'],\n  ['axe', 'axes'],\n  ['die', 'dice'],\n  ['yes', 'yeses'],\n  ['foot', 'feet'],\n  ['eave', 'eaves'],\n  ['goose', 'geese'],\n  ['tooth', 'teeth'],\n  ['quiz', 'quizzes'],\n  ['human', 'humans'],\n  ['proof', 'proofs'],\n  ['carve', 'carves'],\n  ['valve', 'valves'],\n  ['looey', 'looies'],\n  ['thief', 'thieves'],\n  ['groove', 'grooves'],\n  ['pickaxe', 'pickaxes'],\n  ['passerby', 'passersby'],\n  ['canvas', 'canvases']\n]\nconst defaultPlurals: [Rule, string][] = [\n  [/s?$/i, 's'],\n  [/[^\\u0000-\\u007F]$/i, '$0'],\n  [/([^aeiou]ese)$/i, '$1'],\n  [/(ax|test)is$/i, '$1es'],\n  [/(alias|[^aou]us|t[lm]as|gas|ris)$/i, '$1es'],\n  [/(e[mn]u)s?$/i, '$1s'],\n  [/([^l]ias|[aeiou]las|[ejzr]as|[iu]am)$/i, '$1'],\n  [\n    /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,\n    '$1i'\n  ],\n  [/(alumn|alg|vertebr)(?:a|ae)$/i, '$1ae'],\n  [/(seraph|cherub)(?:im)?$/i, '$1im'],\n  [/(her|at|gr)o$/i, '$1oes'],\n  [\n    /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i,\n    '$1a'\n  ],\n  [\n    /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i,\n    '$1a'\n  ],\n  [/sis$/i, 'ses'],\n  [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, '$1$2ves'],\n  [/([^aeiouy]|qu)y$/i, '$1ies'],\n  [/([^ch][ieo][ln])ey$/i, '$1ies'],\n  [/(x|ch|ss|sh|zz)$/i, '$1es'],\n  [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, '$1ices'],\n  [/\\b((?:tit)?m|l)(?:ice|ouse)$/i, '$1ice'],\n  [/(pe)(?:rson|ople)$/i, '$1ople'],\n  [/(child)(?:ren)?$/i, '$1ren'],\n  [/eaux$/i, '$0'],\n  [/m[ae]n$/i, 'men'],\n  ['thou', 'you']\n]\nconst defaultSingles: [Rule, string][] = [\n  [/s$/i, ''],\n  [/(ss)$/i, '$1'],\n  [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\\w]|^)li)ves$/i, '$1fe'],\n  [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, '$1f'],\n  [/ies$/i, 'y'],\n  [/(dg|ss|ois|lk|ok|wn|mb|th|ch|ec|oal|is|ck|ix|sser|ts|wb)ies$/i, '$1ie'],\n  [\n    /\\b(l|(?:neck|cross|hog|aun)?t|coll|faer|food|gen|goon|group|hipp|junk|vegg|(?:pork)?p|charl|calor|cut)ies$/i,\n    '$1ie'\n  ],\n  [/\\b(mon|smil)ies$/i, '$1ey'],\n  [/\\b((?:tit)?m|l)ice$/i, '$1ouse'],\n  [/(seraph|cherub)im$/i, '$1'],\n  [\n    /(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|t[lm]as|gas|(?:her|at|gr)o|[aeiou]ris)(?:es)?$/i,\n    '$1'\n  ],\n  [\n    /(analy|diagno|parenthe|progno|synop|the|empha|cri|ne)(?:sis|ses)$/i,\n    '$1sis'\n  ],\n  [/(movie|twelve|abuse|e[mn]u)s$/i, '$1'],\n  [/(test)(?:is|es)$/i, '$1is'],\n  [\n    /(alumn|syllab|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i,\n    '$1us'\n  ],\n  [\n    /(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i,\n    '$1um'\n  ],\n  [\n    /(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i,\n    '$1on'\n  ],\n  [/(alumn|alg|vertebr)ae$/i, '$1a'],\n  [/(cod|mur|sil|vert|ind)ices$/i, '$1ex'],\n  [/(matr|append)ices$/i, '$1ix'],\n  [/(pe)(rson|ople)$/i, '$1rson'],\n  [/(child)ren$/i, '$1'],\n  [/(eau)x?$/i, '$1'],\n  [/men$/i, 'man']\n]\nconst defaultUncountables: Rule[] = [\n  // Singular words with no plurals.\n  'adulthood',\n  'advice',\n  'agenda',\n  'aid',\n  'aircraft',\n  'alcohol',\n  'ammo',\n  'analytics',\n  'anime',\n  'athletics',\n  'audio',\n  'bison',\n  'blood',\n  'bream',\n  'buffalo',\n  'butter',\n  'carp',\n  'cash',\n  'chassis',\n  'chess',\n  'clothing',\n  'cod',\n  'commerce',\n  'cooperation',\n  'corps',\n  'debris',\n  'diabetes',\n  'digestion',\n  'elk',\n  'energy',\n  'equipment',\n  'excretion',\n  'expertise',\n  'firmware',\n  'flounder',\n  'fun',\n  'gallows',\n  'garbage',\n  'graffiti',\n  'hardware',\n  'headquarters',\n  'health',\n  'herpes',\n  'highjinks',\n  'homework',\n  'housework',\n  'information',\n  'jeans',\n  'justice',\n  'kudos',\n  'labour',\n  'literature',\n  'machinery',\n  'mackerel',\n  'mail',\n  'media',\n  'mews',\n  'moose',\n  'music',\n  'mud',\n  'manga',\n  'news',\n  'only',\n  'personnel',\n  'pike',\n  'plankton',\n  'pliers',\n  'police',\n  'pollution',\n  'premises',\n  'rain',\n  'research',\n  'rice',\n  'salmon',\n  'scissors',\n  'series',\n  'sewage',\n  'shambles',\n  'shrimp',\n  'software',\n  'staff',\n  'swine',\n  'tennis',\n  'traffic',\n  'transportation',\n  'trout',\n  'tuna',\n  'wealth',\n  'welfare',\n  'whiting',\n  'wildebeest',\n  'wildlife',\n  'you',\n  /pok[eé]mon$/i,\n  // Regexes.\n  /[^aeiou]ese$/i, // \"chinese\", \"japanese\"\n  /deer$/i, // \"deer\", \"reindeer\"\n  /fish$/i, // \"fish\", \"blowfish\", \"angelfish\"\n  /measles$/i,\n  /o[iu]s$/i, // \"carnivorous\"\n  /pox$/i, // \"chickpox\", \"smallpox\"\n  /sheep$/i\n]\n// Now lets add all the defaults\nfor (const [single, plural] of defaultIrregulars) {\n  pluralize.addIrregularRule(single, plural)\n}\nfor (const [search, replacement] of defaultPlurals) {\n  pluralize.addPluralRule(search, replacement)\n}\nfor (const [search, replacement] of defaultSingles) {\n  pluralize.addSingularRule(search, replacement)\n}\nfor (const search of defaultUncountables) {\n  pluralize.addUncountableRule(search)\n}\n\n// D O N E, let's export! 😗\nexport default pluralize\n"],"names":[],"version":3,"file":"types.d.ts.map"}