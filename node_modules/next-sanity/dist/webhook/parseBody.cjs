'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var webhook = require('@sanity/webhook');
var readBody = require('./readBody.cjs');
async function parseBody(req, secret) {
  let waitForContentLakeEventualConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  let signature = req.headers[webhook.SIGNATURE_HEADER_NAME];
  if (Array.isArray(signature)) {
    signature = signature[0];
  }
  const body = await readBody._readBody(req);
  const validSignature = secret ? webhook.isValidSignature(body, signature, secret.trim()) : null;
  if (validSignature !== false && waitForContentLakeEventualConsistency) {
    await new Promise(resolve => setTimeout(resolve, 1e3));
  }
  return {
    body: body.trim() && JSON.parse(body),
    isValidSignature: validSignature
  };
}
async function parseAppBody(req, secret) {
  let waitForContentLakeEventualConsistency = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  const signature = req.headers.get(webhook.SIGNATURE_HEADER_NAME);
  const body = await req.text();
  const validSignature = secret ? webhook.isValidSignature(body, signature, secret.trim()) : null;
  if (validSignature !== false && waitForContentLakeEventualConsistency) {
    await new Promise(resolve => setTimeout(resolve, 1e3));
  }
  return {
    body: body.trim() && JSON.parse(body),
    isValidSignature: validSignature
  };
}
exports.parseAppBody = parseAppBody;
exports.parseBody = parseBody;
//# sourceMappingURL=parseBody.cjs.map
